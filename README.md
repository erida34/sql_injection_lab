# Практика по лабораторной работе: SQL‑инъекции (Flask + SQLite) 

> Цель: на простом веб‑приложении показать, как SQL‑инъекции появляются при строковой конкатенации, чем опасны (обход условий, чтение “чужих” данных), и как устраняются параметризованными запросами.

---

## 1) Требования и запуск 

### Требования

* Python 3.11
* Flask
* SQLite (встроен в Python)

### Запуск

1. Создать и активировать venv:

   ```bash
   python -m venv venv
   source venv/bin/activate   # Windows: venv\Scripts\activate
   ```
2. Установить Flask:

   ```bash
   pip install flask
   ```
3. Запустить приложение:

   ```bash
   python app.py
   ```
4. Открыть в браузере:

   * [http://127.0.0.1:5000](http://127.0.0.1:5000)

---

## 2) Описание стенда 

### Страницы

* `GET /` — каталог товаров: таблица + поиск по названию/категории через `q`.
* `POST /create` — форма добавления товара.

### Схема БД

* `products(id, name, category, price)`
* `app_secrets(id, name, secret)` — служебная таблица с секретами (для демонстрации утечки)

> Важно: приложение “доверяет” результату SQL и выводит его в таблицу. Если запрос подменили так, что он начал возвращать строки из другой таблицы, интерфейс этого не “заметит”.

---

## 3) Что сдавать (артефакты) 

* Скриншоты:

  * Нормальный поиск (ожидаемое сужение выдачи).
  * Ошибка SQL при специальном вводе (доказательство уязвимости).
  * Обход условия (выдача расширилась неожиданно).
  * Демонстрация чтения данных из `app_secrets` (секреты видны в таблице каталога).
  * После исправления (параметризация): те же попытки больше не дают эффекта.
* Код фрагментов “до/после” для SELECT и INSERT.
* Короткие пояснения: “что ввели → что ожидали → что получили → почему так”.

---

## 4) Практика: SQL‑инъекции через GET (поиск) 

### 4.1 Нормальное поведение

1. Введите обычную подстроку в поиск.
2. Зафиксируйте, что таблица показывает только совпадения.

### 4.2 Доказательство “ввод стал частью SQL”

1. Введите строку со спецсимволами SQL так, чтобы запрос стал некорректным.
2. Зафиксируйте текст ошибки.

Вывод для отчёта: если ошибка меняется в зависимости от ввода — значит, ввод попадает в SQL‑синтаксис, а не только в данные.

### 4.3 Обход условия

1. Подберите ввод, который превращает условие поиска в “истина для многих строк”.
2. Зафиксируйте, что выдача резко расширилась.

### 4.4 Утечка данных из `app_secrets` (идея UNION)

1. Определите число выводимых колонок в каталоге (в этой версии их 3: `name`, `category`, `price`).
2. Подберите объединение выборок так, чтобы по количеству колонок оно совпало.
3. Добейтесь, чтобы строки/значения из `app_secrets` оказались видимыми в таблице каталога.

---

## 5) Исправление

### 5.1 Параметризованный SELECT

* Перепишите поиск на placeholders `?` в sqlite3.
* Проверьте, что “вредный” ввод больше не ломает запрос и не расширяет выдачу.

---

## 6) Контрольные вопросы 

1. Что такое SQL‑инъекция и почему она опасна?
2. Почему строковая конкатенация пользовательского ввода приводит к уязвимостям?
3. Чем отличаются: обход условий, утечка через объединение выборок, несколько команд в одном запросе?
4. Какие меры защиты обязательны?

---
