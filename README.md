Практика по лабораторной работе: SQL‑инъекции (Flask + SQLite)

> Цель: на простом веб‑приложении показать, как SQL‑инъекции возникают при конкатенации строк, чем опасны (обход фильтров, чтение “чужих” данных), и как исправляются параметризованными запросами.

***

## 1) Требования и запуск

### Требования
- Python 3.11
- Flask
- SQLite (встроен в Python)

### Запуск
1. Создать и активировать venv:
   ```bash
   python -m venv venv
   source venv/bin/activate   # Windows: venv\Scripts\activate
   ```
2. Установить зависимости:
   ```bash
   pip install -r requirements.txt
   ```
3. Запустить:
   ```bash
   python app.py
   ```
4. Открыть:
   - http://127.0.0.1:5000

***

## 2) Описание стенда

### Страницы
- `GET /` — “админка”: таблица пользователей и строка поиска по имени пользователя (поиск идёт через GET‑параметр `q`).
- `POST /create` — форма добавления пользователя.

### Схема БД (пример)
- `users(id, username, email, password, role)`
- `app_secrets(id, name, secret)` — “служебная” таблица с секретами (для демонстрации утечки).

***

## 3) Что сдавать (артефакты)
- Скриншоты:
  - Рабочий “нормальный” поиск.
  - Ошибка SQL при специальном вводе (доказательство уязвимости).
  - Обход фильтра (возвращаются все пользователи).
  - Утечка данных из второй таблицы (секреты отображаются в таблице пользователей).
  - Исправление: те же попытки после параметризации больше не работают.
- Код уязвимого и безопасного вариантов запросов.
- Короткие пояснения по каждому шагу: “что ввели → что ожидали → что получили → почему так”.

***

## 4) Практика: SQL‑инъекции через GET (поиск)

> Важно: в этой части не используется “удаление таблиц”, потому что стандартный драйвер SQLite в Python обычно не выполняет несколько SQL‑команд за один `execute()` (это ограничение/защита). Поэтому акцент — на обходе условий и чтении данных (UNION).

### Задание 4.1 — Нормальное поведение
1. Введите в поиск обычную подстроку имени (например, часть имени пользователя).
2. Зафиксируйте, что выдача сужается и показывает только совпадения.

**Что показать в отчёте:**
- URL с `?q=...`
- Таблица с ожидаемым результатом.

### Задание 4.2 — Доказательство “ввод попадает в SQL”
1. Введите строку со спецсимволами SQL (кавычки/комментарии), чтобы приложение вернуло ошибку SQL.
2. Зафиксируйте текст ошибки и сделайте вывод: “ввод вставляется в запрос как синтаксис”.

**Что показать в отчёте:**
- Скриншот страницы с ошибкой.
- Пояснение: “ошибка появилась из‑за некорректного SQL, значит запрос строится строковой конкатенацией”.

### Задание 4.3 — Обход фильтра
1. Подберите ввод, который превращает условие поиска в “истина для всех строк”.
2. Убедитесь, что возвращаются все пользователи (или заметно больше, чем при обычном поиске).

**Что показать в отчёте:**
- URL запроса.
- Таблица, где отображаются все пользователи.

### Задание 4.4 — Утечка данных из `app_secrets` (концепция UNION)
1. Выясните, сколько колонок возвращает исходный запрос (сопоставьте с таблицей на странице: например `id, username, email, password, role`).
2. Подберите UNION‑вставку, которая по количеству колонок совпадает с исходным SELECT.
3. Добейтесь, чтобы в таблице “пользователей” появились строки из таблицы `app_secrets` (например, чтобы “secret” оказался в колонке `password` или `email`).

**Что показать в отчёте:**
- Ввод/URL.
- На экране должны быть видны “секреты”, но они отображаются в “таблице пользователей”.
- Пояснение: “страница не отличает источники данных — она доверяет результату SQL”.

***

## 5) Практика: SQL‑инъекции через POST (форма создания)

### Задание 5.1 — Нормальное создание пользователя
1. Создайте пользователя обычными значениями.
2. Убедитесь, что новый пользователь появился в таблице.

**Что показать в отчёте:**
- Заполненная форма (скрин).
- Новая строка в таблице.

### Задание 5.2 — Ошибка при “спецвводе” (доказательство уязвимости)
1. Введите в одно из полей данные со спецсимволами SQL так, чтобы INSERT “сломался” и вернул ошибку.
2. Зафиксируйте сообщение об ошибке.

**Что показать в отчёте:**
- Скриншот ошибки.
- Пояснение: “ввод попал в SQL‑синтаксис, а не только в данные”.

### Задание 5.3 — “Вычисляемое значение” вместо текста (если уязвимость позволяет)
Если в форме/коде есть поле, которое подставляется без кавычек (или без корректной параметризации), покажите, что вместо “строки” можно заставить БД вычислить выражение и сохранить результат.

**Что показать в отчёте:**
- Заполненная форма.
- Результат в таблице отличается от ожидаемого (например, вместо введённого отображается вычисленный результат).
- Пояснение: “пользователь контролирует SQL‑структуру/выражения, а не только значение”.

***

## 6) Исправление (обязательная часть)

### Задание 6.1 — Параметризованный SELECT (поиск)
1. Перепишите уязвимый запрос поиска на параметризованный (placeholders `?` в sqlite3).
2. Убедитесь, что “вредные” строки больше не ломают запрос и не расширяют выдачу.

**Что показать в отчёте:**
- Фрагмент кода “до/после”.
- Скриншот: та же попытка “инъекции” теперь не даёт эффекта.

### Задание 6.2 — Параметризованный INSERT (создание)
1. Перепишите INSERT на `VALUES (?, ?, ...)`.
2. Убедитесь, что спецсимволы сохраняются как текст, а не влияют на SQL.

***

## 7) Контрольные вопросы (для отчёта)
1. Что такое SQL‑инъекция и почему она опасна для веб‑приложений?
2. Почему строковая конкатенация пользовательского ввода в SQL приводит к уязвимостям?
3. Чем отличаются:
   - “обход условий” (логическая инъекция),
   - UNION‑утечка данных,
   - stacked queries (несколько команд)?
4. Почему в SQLite через стандартный драйвер Python часто не удаётся выполнить stacked queries?
5. Какие меры защиты обязательны (параметризация, валидация, права доступа, скрытие ошибок)?

***

## 8) Критерии успешного выполнения
- Показаны минимум 2 разные проблемы из-за SQLi (например: обход фильтра + утечка секретов).
- Продемонстрировано исправление (параметризация) и проверено, что атаки больше не работают.
- Есть пояснения “почему так происходит”, а не только скриншоты.

***